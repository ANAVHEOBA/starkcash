//! Nullifier generation and validation
//!
//! Prevents double-spending by ensuring each note is used only once

//! Prevents double-spending by ensuring each note is used only once.
//! Nullifiers are random 32-byte values generated by the client.

use crate::module::cryptography::poseidon::poseidon_hash_single;

/// 32-byte nullifier value
pub type Nullifier = [u8; 32];

/// 32-byte nullifier hash stored on-chain
pub type NullifierHash = [u8; 32];


/// Generate nullifier hash from nullifier
///
/// Formula: nullifierHash = Poseidon(nullifier)
///
/// # Arguments
/// * `nullifier` - 32-byte nullifier value
///
/// # Returns
/// 32-byte nullifier hash
pub fn generate_nullifier_hash(nullifier: &[u8]) -> NullifierHash {
    assert_eq!(nullifier.len(), 32, "Nullifier must be 32 bytes");

    let mut n = [0u8; 32];
    n.copy_from_slice(nullifier);
    poseidon_hash_single(&n)
}

/// Check if nullifier hash has been spent
///
/// # Arguments
/// * `nullifier_hash` - The hash to check
/// * `spent_nullifiers` - Set of already spent nullifiers
///
/// # Returns  
/// `true` if not spent (unique), `false` if already spent
pub fn is_nullifier_unique(nullifier_hash: &NullifierHash, spent_nullifiers: &[[u8; 32]]) -> bool {
    !spent_nullifiers.contains(nullifier_hash)
}

/// Mark nullifier as spent
///
/// # Arguments
/// * `nullifier_hash` - Hash to mark
/// * `spent_set` - Mutable set of spent nullifiers
pub fn mark_nullifier_spent(nullifier_hash: NullifierHash, spent_set: &mut Vec<NullifierHash>) {
    if !spent_set.contains(&nullifier_hash) {
        spent_set.push(nullifier_hash);
    }
}



/// Generate random nullifier
///
/// # Returns
/// 32-byte unique nullifier
pub fn random_nullifier() -> Nullifier {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    let mut nullifier = [0u8; 32];
    rng.fill(&mut nullifier);
    nullifier
}
